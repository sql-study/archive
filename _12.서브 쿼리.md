하나의 쿼리 블록으로 구성된 쿼리. 쿼리 블록은 다른 쿼리 블록을 포함할 수 있다. 다른 쿼리 블록에 초함된 쿼리 블록을 **서브 쿼리**, 다른 쿼리 블록을 포함한 쿼리 블록을 **메인 쿼리**



![image-20200321201322549](https://tva1.sinaimg.cn/large/00831rSTgy1gd1rhfhsmcj30z40f6thl.jpg)



서브 쿼리는 사용 위치에 따라 중첩 서브 쿼리, 스칼라 서브 쿼리, 인라인 뷰



**중첩 서브 쿼리 - WHERE 절, HAVING 절**

**스칼라 서브 쿼리 - SELECT 절**

**인라인 뷰 - FROM 절**



```sql
DROP TABLE t1 PURGE;
DROP TABLE t2 PURGE;

CREATE TABLE t1(c1 NUMBER NOT NULL, C2 NUMBER NOT NULL);
CREATE TABLE t2(c1 NUMBER NOT NULL, C2 NUMBER);

INSERT INTO t1 VALUES (1, 2);
INSERT INTO t1 VALUES (2, 1);
INSERT INTO t1 VALUES (2, 3);
INSERT INTO t1 VALUES (3, 4);
INSERT INTO t2 VALUES (1, 2);
INSERT INTO t2 VALUES (2, 3);
INSERT INTO t2 VALUES (3, NULL);
```

# 중첩 서브 쿼리(nested subquery)

중첩 서브 쿼리는 WHERE 절과 HAVING 절에 사용하는 서브 쿼리.

```
비상관(uncorrelated subquery) 서브 쿼리 - 메인 쿼리와 관계 없음.
상관(correlated subquery) 서브 쿼리 - 메인 쿼리와 관계 있음.
```

서브 쿼리가 반환하는 행의 개수에 따라 단일 행 서브 쿼리와 다중 행 서브 쿼리로도 구분

```
단일 행 서브 쿼리 - 서브 쿼리가 단일 행을 반환
다중 행 서브 쿼리 - 서브 쿼리가 다중 행을 반환
```

## 1. 비상관 서브 쿼리

- 메인 쿼리와 관계가 없는 서브 쿼리. 서브 쿼리의 WHERE 절에 메인 쿼리와의 조인 조건이 존재하지 않는다.
- 비상관 서브 쿼리가 반환하는 행의 개수에 따라 단일 행 비상관 서브 쿼리와 다중 행 비상관 서브 쿼리로 구분



### 1.1 단일 행 비상관 서브 쿼리

단일 행을 반환하는 비상관 서브 쿼리. 주로 비교 조건을 사용.

```sql
SELECT * FROM t1 WHERE c1 = (SELECT MAX (c1) AS c1 FROM t2);
-- 단일 행 쿼리가 반환되서 결과가 반환된다.
---
SELECT * FROM t1 WHERE c1 = 2;
```

```sql
SELECT * FROM t1 WHERE (c1, c2) = (SELECT MAX(c1), MAX(c2) FROM t2);
-- 다중 열일 경우는 위와같이
---
SELECT * FROM t1 WHERE (c1, c2) = ((2,3));
```

`HAVING` 절에도 서브 쿼리를 사용할 수 있음.



### 1.1 다중 행 비상관 서브 쿼리

다중 행을 반환하는 비상관 서브 쿼리. 주로 `IN 조건`

#### IN 조건

서브 쿼리의 결과에 해당하는 메인 쿼리의 행을 조회

```sql
SELECT * FROM t1 WHERE c1 IN (SELECT c1 FROM t2);
-- 
---
SELECT * FROM t1 WHERE c1 IN (1,2);
```



#### ANY조건과 ALL조건

ANY 조건은 서브 쿼리 결과의 일부, ALL 조건은 서브 쿼리 결과의 전체를 비교하여 조건에 만족하는 행을 반환

![image-20200322135525351](https://tva1.sinaimg.cn/large/00831rSTgy1gd2m6hkqfvj310e0mgwuw.jpg)

## 상관 서브 쿼리

메인 쿼리와 관계가 있는 서브 쿼리. 서브 쿼리의 WHERE 절에 메인 쿼리와의 조인조건이 존재.

상관 서브 쿼리도 서브 쿼리가 반환하는 행의 개수에 따라
 

**단일 행 상관 서브 쿼리**와 **다중 행 상관 서브 쿼리**로 구분

### 1. 단일 행 상관 서브 쿼리

메인 쿼리의 열을 서브 쿼리의 결과와 비교할 때 사용.

```sql
SELECT a.고객번호, b.주문번호, b.주문일자
 FROM 개인고객 a, 주문 b
 WHERE b.주문고객번호=a.고객번호
 AND b.주문일자=(SELECT MAX (x.주문일자) FROM 주문 x WHERE x.주문고객번호 = a.고객번호);
```

개인고객(a) -> 주문(x) -> 주문(b) 순서로 조인.

```sql
SELECT a.*
FROM t1 a
WHERE (SELECT MAX(x.c2) FROM t2 x WHERE x.c1 = a.c1) >= 3;

---
-- 아래 쿼리가 좀 더 효율적. 왜? 위 커리는 
-- 서브 쿼리의 결과를 리터럴과 비교했기 때문에.
SELECT *
FROM t1
WHERE c1 IN (SELECT c1 FROM t2 GROUP BY c1 HAVING MAX(c2) >= 3);
```

```sql
SELECT a.*
FROM t1 a
WHERE (SELECT MAX(1) FROM t2 x WHERE x.c1 = a.c1) IS NOT NULL;
---
-- IS NOT NULL은 성능 저하를 일으킴.
SELECT a.*
FROM t1 a
WHERE EXISTS (SELECT 1 FROM t2 x WHERE x.c1 = a.c1);

```



### 2. 다중 행 상관 서브 쿼리

다중 행을 반환하는 상관 서브 쿼리 > 주로 EXISTS 조건을 사용한다.

`[NOT] EXISTS(Subquery)`





## 사용 기준

![image-20200324094809512](https://tva1.sinaimg.cn/large/00831rSTgy1gd4q9t7flkj310o06wgr6.jpg)







원래의 의미에 맞게 사용 -> 내부적인 동작은 신경 쓸 필요 X

`IN 조건` > 서브 쿼리를 먼저 조회하고, 메인 쿼리에 값을 공급

`EXISTS 조건` > 메인 쿼리를 먼저 조회하여, 서브 쿼리로 존재 여부를 확인.

```sql
-- 사원이 소속된 부서를 조회
SELECT deptno, dname
FROM dept
WHERE deptno IN (SELECT deptno FROM emp);
---
-- 사원이 존재하는 부서
SELECT a.deptno, a.dname
FROM dept a
WHERE EXISTS (SELECT 1 FROM emp x WHERE x.deptno = a.deptno);

-- 결과는 같지만 의미는 다르다.
```

![image-20200324094625404](https://tva1.sinaimg.cn/large/00831rSTgy1gd4q83lp40j30u01757os.jpg)



# 스칼라 서브 쿼리

*SELECT 사용하는 서브 쿼리. 스칼라는 **단일 값(단일 행, 단일 열)**을 의미*



스칼라 서브 퀄를 사용한 쿼리 => 결과가 없으면 널을 반환

```sql
SELECT a.c1, (SELECT MAX(x.c2) FROM t2 x WHERE x.c1 = a.c1) AS c2 FROM t1 a;

-- null 반환 가능
```

```sql
SELECT (SELECT x.c2 FROM t2 x WHERE x.c1 = a.c1) AS c2 FROM t1 a;

-- 단일 행 하위 질의에 2개 이상의 행이 리턴 그래서 오류가 발생한
ORA-01427 
```

# 인라인 뷰

**FROM절에 사용하는 서브 쿼리**

*뷰(View)는 데이터베이스에 저장한 SELECT 문을 테이블처럼 사용할 수 있는 객체* 

인라인 뷰는 쿼리에서 즉시 처리되는(inline)뷰를 의미.



뷰는 결과 집합의 변경 여부에 따라 단순 뷰, 복합 뷰로 구분 

```sql
SELECT a.dname, b.ename
FROM (SELECT * FROM dept WHERE loc='DALLAS') a,
		 (SELECT * FROM emp WHERE job='CLERK') b
WHERE b.deptno=a.deptno;

-- 이렇게 하더라도 아래 쿼리와 논리적으로 동일하게 동작되고 옵티마지어에 의해 메인쿼리와 병합됨.
SELECT a.dname, b.ename
FROM dept a, emp b
WHERE a.loc =  'DALLAS'
AND b.deptno = a.deptno
AND b.job = 'CLERK';
```

# 사용 기준

- 언제 조인을 사용해야 하는지.
- 언제 서브 쿼리를 사용하는지.
- 조인과 서브쿼리의 사용 기준은 조인 차수와 관련이 있음.



조인 > 조인 기준의 행이 줄어들거나 늘어날 수 있음

중첩 서브 쿼리 > 메인 쿼리의 행이 줄어들 수 있지만 늘어나지는 않음

스칼라 서브 쿼리 > 메인 쿼리의 행이 변하지 않음

인라인 뷰 > 메인 쿼리의 행이 줄어들거나 늘어날 수 있음(조인 동일)



**조인**

*조인은 테이블을 연결하는 기본 방식*
조인을 사용한 쿼리

dept 테이블을 조인 기준으로 보면 조인 차수가 1:M 이기 때문에 dept 테이블의 행이 M으로 늘어난다. 조인이 실패한 행은 반환 X



**중첩 서브 쿼리**

서브 쿼리로 메인 쿼리의 결과 집합을 제한할 때 사용한다. EXISTS 조건과 NOT EXISTS조건

메인 쿼리(dept)와 서브 쿼리(emp)의 조인 차수가 1:M이지만 메인 쿼리의 행이 M으로 늘어나지 않는다.



**스칼라 서브쿼리**

서브 쿼리로 단일 값을 조회할 때 사용

스칼라 서브 쿼리는 메인 쿼리와 서브 쿼리의 조인 차수가 1:M일 때 사용하는 것이 일반적.



**인라인 뷰**

**복합 뷰**는 인라인 뷰로 새로운 결과 집합을 만들거나 조인 차수를 1:1 관계로 만들 때 사용

**단순 뷰**는 조인 순서를 제어하거나 반복되는 표현식을 제거할 때 사용.



# WITH 절

서브 쿼리를 별도의 절에 기술

## 1. SUBQUERY FACTORING 절

```sql
WITH query_name AS (subquery)
[, query_name AS (subquery)] ...
SELECT * FROM query_name;
```



## 2. PL/SQL 선언

