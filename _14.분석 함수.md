# 분석 함수

*집계 함수의 확장 기능*

- **분석함수**는 파티션과 원도우로 값을 집계
- 집계 함수는 행 그룹 별로 단일 행을 반환하기 때문에 데이터 집합이 변경되지만, 분석 함수는 데이터 집합을 변경하지 않고 값을 집계.
- **데이터 집합이 변경되지 않기 때문에 원본 값과 집계 값을 함께 분석할 수 있는 장점**

```sql
SELECT a.deptno, 
a.sal, 
b.sal AS c1, 
a.sal / b.sal AS c2

FROM emp a,
     (SELECT deptno,
             SUM(sal) AS sal FROM emp GROUP BY deptno) b

WHERE a.deptno = 10
  AND b.deptno = a.deptno
ORDER BY 1;


SELECT empno, sal,
       SUM(sal) over () AS c1,
       RATIO_TO_REPORT(sal) over () AS c2
FROM emp
WHERE deptno = 10
ORDER BY 1;
```

***RATIO_TO_REPORT 의미는?*
https://thebook.io/006696/part01/ch07/03/04/03/

## 1. 기본 문법

분석 함수는 `OVER 키워드`를 사용. 집계 함수에 OVER 키워드를 기술하면 분석 함수로 동작.

 `OVER 키워드에 ANALYTIC 절 ` 기술 

`ANALYTIC 절` 은 

` QUERY PARITIION 절, ORDER BY 절, WINDOWING 절`

구성된다. 

`[query_partition_clause] [order_by_clause [windowing_clause]]`

![image-20200321210126381](https://tva1.sinaimg.cn/large/00831rSTgy1gd1svfl0kpj30xg0d248q.jpg)

### 1.3 QUERY PARTITION 

**expr로 파티션을 지정**할 수 있다. 

- QUERY PARTITION 절은 GROUP BY 절과 유사하게 동작.

- `PARTITION BY expr[, expr]... `

  아래 쿼리의 c1열은 job을 파티션으로 지정



**cf) 여기서 파티션은 무엇일까?**

- 파티션은 행 그룹과 유사하다. 

- 분석을 위한 정적(static )그룹으로 생각할 수 있다. 
- QUERY PARTITION 절을 생략하면 전체 행이 하나의 파티션으로 동작한다.

![image-20200321205838634](https://tva1.sinaimg.cn/large/00831rSTgy1gd1ssizi2tj30x60mwnbf.jpg)

## 2. ORDER BY 절

ORDER BY 절로 파티션 내의 정렬 순서를 지정

`ORDER BY expr [ASC | DESC] [NULLS FIRST | NULLS LAST][, expr [ASC | DESC] [NULLS FIRST | NULLS LAST]]`

```sql
SELECT empno, sal, SUM(sal) OVER (ORDER BY sal, empno) AS c1
FROM emp
WHERE deptno = 30
ORDER BY 2, 1;
```

![image-20200321210326026](https://tva1.sinaimg.cn/large/00831rSTgy1gd1sxihd6jj30yo0ho0yv.jpg)



## 3. WINDOWING 절

파티션의 원도우를 지정할 수 있음.

원도우는 현재 행에 따라 범위가 변경될 수 있음. 원도우는 파티션 내의 동적(dynamic) 그룹으로 생각

![image-20200321210442000](https://tva1.sinaimg.cn/large/00831rSTgy1gd1sytw3ehj30xu0h47jv.jpg)

![image-20200321210515528](https://tva1.sinaimg.cn/large/00831rSTgy1gd1szevzg5j30yu0omwwc.jpg)



![image-20200321210634468](https://tva1.sinaimg.cn/large/00831rSTgy1gd1t0xkrvbj30u012l1kx.jpg)



--

![image-20200321211213181](https://tva1.sinaimg.cn/large/00831rSTgy1gd1t6o4v6fj30u00vd1dl.jpg)

![image-20200321211224220](https://tva1.sinaimg.cn/large/00831rSTgy1gd1t6t9cgej30yg0qsk7a.jpg)





예제를 통해 이해해보자.

```sql
DROP TABLE t1 PURGE;
CREATE TABLE t1 (c1 NUMBER, C2 NUMBER);
INSERT INTO t1 VALUES (1, 1);
INSERT INTO t1 VALUES (2, 1);
INSERT INTO t1 VALUES (3, 2);
INSERT INTO t1 VALUES (4, 3);
INSERT INTO t1 VALUES (5, 3);
INSERT INTO t1 VALUES (6, 4);
INSERT INTO t1 VALUES (7, 5);
INSERT INTO t1 VALUES (8, 5);
INSERT INTO t1 VALUES (9, 6);



SELECT c1, c2 ,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN UNBOUNDED PRECEDING AND 2 PRECEDING ) AS r01,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS r02,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN UNBOUNDED PRECEDING AND 2 FOLLOWING ) AS r03,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS r04,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN 2 PRECEDING AND 1 PRECEDING ) AS r05,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN 2 PRECEDING AND CURRENT ROW ) AS r06,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING ) AS r07,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN 2 PRECEDING AND UNBOUNDED FOLLOWING ) AS r08,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING ) AS r09,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) AS r10,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING ) AS r11,
  COUNT(*) OVER (ORDER BY c2 ROWS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING ) AS r12,
  COUNT(*) OVER (ORDER BY c2 ROWS UNBOUNDED PRECEDING ) AS r13,
  COUNT(*) OVER (ORDER BY c2 ROWS 2 PRECEDING ) AS r14,
  COUNT(*) OVER (ORDER BY c2 ROWS CURRENT ROW ) AS r15
  FROM t1
     ORDER BY 1;
```

![image-20200322013339378](https://tva1.sinaimg.cn/large/00831rSTgy1gd20qqkcwij30ye0f07cd.jpg)

![image-20200322013330294](https://tva1.sinaimg.cn/large/00831rSTgy1gd20qj3o3fj31120h6qhc.jpg)





```sql
SELECT c1, c2 ,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN UNBOUNDED PRECEDING AND 2 PRECEDING ) AS r01,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS r02,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN UNBOUNDED PRECEDING AND 2 FOLLOWING ) AS r03,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS r04,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN 2 PRECEDING AND 1 PRECEDING ) AS r05,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN 2 PRECEDING AND CURRENT ROW ) AS r06,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN 2 PRECEDING AND 2 FOLLOWING ) AS r07,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN 2 PRECEDING AND UNBOUNDED FOLLOWING ) AS r08,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN CURRENT ROW AND 2 FOLLOWING ) AS r09,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) AS r10,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN 1 FOLLOWING AND 2 FOLLOWING ) AS r11,
  COUNT(*) OVER (ORDER BY c2 RANGE BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING ) AS r12,
  COUNT(*) OVER (ORDER BY c2 RANGE UNBOUNDED PRECEDING ) AS r13,
  COUNT(*) OVER (ORDER BY c2 RANGE 2 PRECEDING ) AS r14,
  COUNT(*) OVER (ORDER BY c2 RANGE CURRENT ROW ) AS r15
  FROM t1
     ORDER BY 1;
```

![image-20200322014718092](https://tva1.sinaimg.cn/large/00831rSTgy1gd214x5wnaj310u0rux6k.jpg)

## 4. KEEP 키워드

분석 함수도 KEEP 키워드를 사용.

**KEEP 키워드를 사용하면 ANALYTIC 절에 QUERY PARTITION절만 사용.**

![image-20200321211934193](/Users/lenkim/Library/Application Support/typora-user-images/image-20200321211934193.png)

![image-20200321212225578](https://tva1.sinaimg.cn/large/00831rSTgy1gd1thbtiyfj30yh0u0gpl.jpg)



참고

http://www.gurubee.net/lecture/2674

http://www.gurubee.net/lecture/2671 



*추가내용*

#### 분석함수란?

- \- 테이블에 있는 데이터를 특정 용도로 분석하여 결과를 반환하는 함수
- \- 복잡한 계산을 단순하게 처리해주는 함수
- \- 쿼리 결과Set을 대상으로 계산을 수행하는 함수
- \- SELECT 절에서 수행됨
  - FROM, WHERE, GROUP BY 절에서 사용 불가
  - ORDER BY 구문에서는 사용 가능
- \- 오라클 8.1.6 부터 분석함수 지원



![image-20200322015119099](https://tva1.sinaimg.cn/large/00831rSTgy1gd2194z0hqj30vg0p6wgu.jpg)

![image-20200322015138650](https://tva1.sinaimg.cn/large/00831rSTgy1gd219gnwp6j30yq0t0q61.jpg)



###### 집계함수 vs 분석함수

- 집계함수는 그룹별 최대, 최소, 합계, 평균, 건수 등을 구할 때 사용되며, 그룹별 1개의 행을 반환한다.
- 분석함수는 그룹단위로 값을 계산한다는 점에서 집계함수와 유사하지만, 그룹마다가 아니라 결과Set의 각 행마다 집계결과를 보여준다는 점에서 집계함수와 상당한 차이가 있다.
- 분석함수는 쉽게 생각해서, 그룹별 계산결과를 각 행마다 보여주는 것이다.



#### 분석함수의 종류

- 순위함수 : RANK, DENSE_RANK, ROW_NUMBER, NTILE
- 집계함수 : SUM, MIN, MAX, AVG, COUNT
- 기타함수 : LEAD, LAG, FIRST_VALUE, LAST_VALUE, RATIO_TO_REPORT
- 분석함수(?) : KEEP, LISTAGG



*NTILE*

: order_by_clause에 따라 행을 정렬하고, expr의 개수반큼 버킷을 생성한 후, 행에 해당하는 버킷 번호를 할당.

![image-20200322091705345](https://tva1.sinaimg.cn/large/00831rSTgy1gd2e4uoykqj31220r8qmm.jpg)

*LAG*

: 

![image-20200322092058525](https://tva1.sinaimg.cn/large/00831rSTgy1gd2e8wbp8pj310i098ti3.jpg)

*LEAD*

:
![image-20200322092414839](https://tva1.sinaimg.cn/large/00831rSTgy1gd2ecbgbj8j30z50u0nfk.jpg)



# # 분석 함수 종류

*분석 함수는 집계 함수와 유사하게 구분.*

- 분석 함수를 원도우 함수로 부른다.
- ![image-20200321234247264](https://tva1.sinaimg.cn/large/00831rSTgy1gd1xjdxathj30s00lswph.jpg)

![image-20200321234302476](https://tva1.sinaimg.cn/large/00831rSTgy1gd1xjjwa93j30s40d60xd.jpg)



## 1. 기본 함수

### 1.1 COUNT

![image-20200321234344160](https://tva1.sinaimg.cn/large/00831rSTgy1gd1xkachmlj30s00kswn1.jpg)

![image-20200321234920896](https://tva1.sinaimg.cn/large/00831rSTgy1gd1xq6o74wj30uq0qe7gf.jpg)



### 1.3 순위 함수

order_by_clause에 따른 순위 반환. expr이 동일하면 동순위를 부여하고, 다음 순위는 동순위의 개수만큼 건너 뛴다.

`RANK () OVER ([query_partition_clause] order_by_caluse)`

![image-20200322000422209](https://tva1.sinaimg.cn/large/00831rSTgy1gd1y5qxevqj30a409yace.jpg)





![image-20200322000435246](https://tva1.sinaimg.cn/large/00831rSTgy1gd1y5zu8azj30u00og49n.jpg)



![image-20200322000640120](https://tva1.sinaimg.cn/large/00831rSTgy1gd1y861acqj30t00hq7c2.jpg)

