# 16. 계층 쿼리

- 411p JONES의 자식 노드 조회
```SQL
SELECT E2.EMPNO, E2.ENAME, E2.MGR 
FROM EMP E2, EMP E1
WHERE
	E1.ENAME = 'JONES' AND
	E2.MGR = E1.EMPNO;
 ```

- 411p JONES의 자식 노드의 자식 노드 조회
```SQL
SELECT E3.EMPNO, E3.ENAME, E3.MGR 
FROM EMP E3, EMP E2, EMP E1
WHERE
	E1.ENAME = 'JONES' AND
	E2.MGR = E1.EMPNO AND 
	E3.MGR = E2.EMPNO;
```

- 412p SMITH의 부모 노드 조회
```SQL
SELECT E2.EMPNO, E2.ENAME, E2.MGR 
FROM EMP E2, EMP E1
WHERE 
	E1.ENAME = 'SMITH' AND
	E2.EMPNO = E1.MGR;
```

- 414p
```SQL
SELECT 
	LEVEL AS LV, 
	EMPNO,
	LPAD(' ', LEVEL - 1, ' ') || ENAME AS ENAME,
	MGR,
	PRIOR EMPNO AS EMPNO_P
FROM EMP
START WITH MGR IS NULL
CONNECT BY MGR = PRIOR EMPNO ;
```
- 오라클에서 길이가 없는 문자열은 NULL로 취급
- DFS(깊이 우선 탐색) 방식으로 조회(그림 참조)


- 415p
```SQL
SELECT 
	LEVEL AS LV,
	EMPNO,
	LPAD(' ', LEVEL - 1, ' ') || ENAME AS ENAME,
	MGR,
	PRIOR EMPNO AS EMPNO_P,
	CONNECT_BY_ROOT ENAME AS RT,
	CONNECT_BY_ISLEAF AS LF,
	SYS_CONNECT_BY_PATH(ENAME, ',') AS PT
FROM EMP
START WITH MGR IS NULL
CONNECT BY MGR = PRIOR EMPNO ;
```


- 419p 역방향 전개
```SQL
SELECT 
	LEVEL AS LV,
	EMPNO,
	LPAD(' ', LEVEL - 1, ' ') || ENAME AS ENAME,
	MGR
FROM EMP
START WITH ENAME = 'ADAMS'
CONNECT BY EMPNO = PRIOR MGR;
```

- 420p 계층 정렬
> 계층 정렬과 무관하게 행이 정렬됨
```SQL
SELECT 
    LEVEL AS LV,
    EMPNO,
    LPAD(' ', LEVEL - 1, ' ') || ENAME AS ENAME,
    MGR,
    SAL
FROM EMP
START WITH MGR IS NULL
CONNECT BY MGR = PRIOR EMPNO
ORDER BY SAL;
```

> SIBLINGS를 사용하면 형제 노드 내에서만 행이 정렬되기 때문에 계층 구조를 유지하면서 정렬
```SQL
SELECT 
    LEVEL AS LV,
    EMPNO,
    LPAD(' ', LEVEL - 1, ' ') || ENAME AS ENAME,
    MGR,
    SAL
FROM EMP
START WITH MGR IS NULL
CONNECT BY MGR = PRIOR EMPNO
ORDER SIBLINGS BY SAL;
```


### 16.4 활용 예제
- 437p 순번 생성(행 복제)
```SQL
SELECT LEVEL AS LV FROM DUAL CONNECT BY LEVEL <= 10;
SELECT LEVEL AS LV, CONNECT_BY_ROOT LEVEL AS RT, CONNECT_BY_ISLEAF AS LF, SYS_CONNECT_BY_PATH(LEVEL, '->') AS PT FROM DUAL CONNECT BY LEVEL <= 10;

SELECT LEVEL AS LV, DEPTNO, DNAME, CONNECT_BY_ROOT DEPTNO AS RT, CONNECT_BY_ISLEAF AS LF, SYS_CONNECT_BY_PATH(DEPTNO, '->') AS PT FROM DEPT CONNECT BY LEVEL <= 2;
SELECT * FROM DEPT;
```



```SQL
SELECT ROWNUM AS RN FROM XMLTABLE ('1 to 100');
SELECT * FROM XMLTABLE ('1 to 2');
```

- 437p 변경 이력 테이블 생성
```SQL
DROP TABLE T1 PURGE;
CREATE TABLE T1 (
	YM VARCHAR2(6) -- 연월
	, BF VARCHAR2(4) -- 변경 전 코드
	, AF VARCHAR2(4) -- 변경 후 코드
	, ID NUMBER
);

INSERT INTO T1 VALUES ('205001', 'A', 'B', 1);
INSERT INTO T1 VALUES ('205001', 'I', 'J', 2);
INSERT INTO T1 VALUES ('205001', 'X', 'Y', 3);
INSERT INTO T1 VALUES ('205004', 'B', 'C', 4);
INSERT INTO T1 VALUES ('205004', 'J', 'K', 5);
INSERT INTO T1 VALUES ('205007', 'C', 'D', 6);
COMMIT;
SELECT * FROM T1;
```


- 438p 코드의 최종 변경 코드 조회
```SQL
SELECT BF, AF, YM
FROM (SELECT YM, CONNECT_BY_ROOT BF AS BF, AF, CONNECT_BY_ISLEAF AS LF
	FROM T1
	CONNECT BY BF = PRIOR AF)
WHERE LF = 1
ORDER BY 1;
```
- 위 쿼리에 LV, LF 등 컬럼 추가
```SQL
SELECT LV, ID, BF, AF, YM, LF
FROM (SELECT LEVEL AS LV, ID, YM, CONNECT_BY_ROOT BF AS BF, AF, CONNECT_BY_ISLEAF AS LF, SYS_CONNECT_BY_PATH(ID, '->') AS PT
	FROM T1
	CONNECT BY BF = PRIOR AF)
WHERE LF = 1
ORDER BY 3;
```

- 위 쿼리의 서브 쿼리 부분만
```SQL
SELECT LEVEL AS LV, ID, YM, CONNECT_BY_ROOT BF AS BF, AF, CONNECT_BY_ISLEAF AS LF, SYS_CONNECT_BY_PATH(ID, '->') AS PT
FROM T1
--WHERE CONNECT_BY_ISLEAF = 1
CONNECT BY BF = PRIOR AF;

SELECT * FROM T1;
```

- 439p 최초 코드의 변경 정보 조회, START WITH 절에서 변경 전 코드가 존재하지 않는 행을 조회한 후 순방향으로 계층을 전개
```SQL
SELECT BF, CD, YM, CN
FROM (SELECT CONNECT_BY_ROOT BF AS BF
	, SUBSTR(SYS_CONNECT_BY_PATH(AF, ','), 2) AS CD
	, SUBSTR(SYS_CONNECT_BY_PATH(YM, ','), 2) AS YM
	, LEVEL AS CN
	, CONNECT_BY_ISLEAF AS LF
	FROM T1 A
	START WITH NOT EXISTS (SELECT 1 FROM T1 X WHERE X.AF = A.BF)
	CONNECT BY BF = PRIOR AF)
WHERE LF = 1
ORDER BY 1;

SELECT BF, CD, YM, CN
FROM (SELECT CONNECT_BY_ROOT BF AS BF
	, SUBSTR(SYS_CONNECT_BY_PATH(AF, ','), 2) AS CD
	, SUBSTR(SYS_CONNECT_BY_PATH(YM, ','), 2) AS YM
	, LEVEL AS CN
	, CONNECT_BY_ISLEAF AS LF
	FROM T1 A
	START WITH NOT EXISTS (SELECT 1 FROM T1 X WHERE X.AF = A.BF)
	CONNECT BY BF = PRIOR AF)
WHERE LF = 1
ORDER BY 1;
```

- 439p 최종 코드의 변경 정보 조회, START WITH 절에서 변경 후 코드가 존재하지 않는 행을 조회한 후 역방향으로 계층을 전개
```SQL
SELECT AF, CD, YM, CN
FROM (SELECT CONNECT_BY_ROOT AF AS AF
	, SUBSTR(SYS_CONNECT_BY_PATH(BF, ','), 2) AS CD
	, SUBSTR(SYS_CONNECT_BY_PATH(YM, ','), 2) AS YM
	, LEVEL AS CN
	, CONNECT_BY_ISLEAF AS LF
	FROM T1 A
	START WITH NOT EXISTS (SELECT 1 FROM T1 X WHERE X.BF = A.AF)
	CONNECT BY AF = PRIOR BF)
WHERE LF = 1
ORDER BY 1;
```



- 440p 생성 순서, 계층 쿼리를 사용하면 순차적으로 계산되는 계정의 생성 순서를 결정할 수 있다.
```SQL
DROP TABLE T1 PURGE;

CREATE TABLE T1(
	CD VARCHAR2(1) -- 계정
	, C1 VARCHAR2(1) -- 계산계정1
	, C2 VARCHAR2(1) -- 계산계정2
	, C3 VARCHAR2(1) -- 계산계정3
	, C4 VARCHAR2(1) -- 계산계정4
);

INSERT INTO T1 VALUES('A', 'B', 'C', 'D', 'E');
INSERT INTO T1 VALUES('B', 'F', 'G', 'H', NULL);
INSERT INTO T1 VALUES('C', 'I', 'J', NULL, NULL);
INSERT INTO T1 VALUES('D', 'K', NULL, NULL, NULL);
INSERT INTO T1 VALUES('E', 'B', 'C', NULL, NULL);
INSERT INTO T1 VALUES('F', 'C', 'D', NULL, NULL);
COMMIT;

SELECT * FROM T1;
```

- 441p 계정의 순서를 결정, 계산이 불필요한 계산계정으로 루트 노드를 생성한 후 역방향으로 계층을 전개
```SQL
SELECT CD, MAX(LEVEL) AS LV
FROM T1 A
START WITH NOT EXISTS (SELECT 1 FROM T1 X WHERE X.CD IN (A.C1, A.C2, A.C3, A.C4))
CONNECT BY PRIOR CD IN (C1, C2, C3, C4)
GROUP BY CD
ORDER BY 2, 1;
```

- 441p 누적 연산, 상위 노드의 SAL를 하위 노드로 누적 집계한다.
```SQL
WITH W1(EMPNO, ENAME, MGR, SAL, LV, C1) AS (
	SELECT EMPNO, ENAME, MGR, SAL, 1 AS LV, SAL AS C1
	FROM EMP
	WHERE MGR IS NULL
	UNION ALL 
	SELECT C.EMPNO, C.ENAME, C.MGR, C.SAL, P.LV + 1 AS LV, P.C1 + C.SAL AS C1
	FROM W1 P EMP C
	WHERE C.MGR = P.EMPNO)
--SELECT * FROM W1;
SEARCH DEPTH FIRST BY EMPNO SET SO
SELECT LV, EMPNO, LPAD(' ', LV - 1, ' ') || ENAME AS ENAME, MGR, SAL, C1
FROM W1
ORDER BY SO;
```
